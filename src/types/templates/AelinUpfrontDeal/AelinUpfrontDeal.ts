// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt,
} from '@graphprotocol/graph-ts'

export class AcceptDeal extends ethereum.Event {
  get params(): AcceptDeal__Params {
    return new AcceptDeal__Params(this)
  }
}

export class AcceptDeal__Params {
  _event: AcceptDeal

  constructor(event: AcceptDeal) {
    this._event = event
  }

  get user(): Address {
    return this._event.parameters[0].value.toAddress()
  }

  get amountPurchased(): BigInt {
    return this._event.parameters[1].value.toBigInt()
  }

  get totalPurchased(): BigInt {
    return this._event.parameters[2].value.toBigInt()
  }

  get amountDealTokens(): BigInt {
    return this._event.parameters[3].value.toBigInt()
  }

  get totalDealTokens(): BigInt {
    return this._event.parameters[4].value.toBigInt()
  }
}

export class BlacklistNFT extends ethereum.Event {
  get params(): BlacklistNFT__Params {
    return new BlacklistNFT__Params(this)
  }
}

export class BlacklistNFT__Params {
  _event: BlacklistNFT

  constructor(event: BlacklistNFT) {
    this._event = event
  }

  get collection(): Address {
    return this._event.parameters[0].value.toAddress()
  }

  get nftID(): BigInt {
    return this._event.parameters[1].value.toBigInt()
  }
}

export class AelinToken extends ethereum.Event {
  get params(): AelinToken__Params {
    return new AelinToken__Params(this)
  }
}

export class AelinToken__Params {
  _event: AelinToken

  constructor(event: AelinToken) {
    this._event = event
  }

  get name(): string {
    return this._event.parameters[0].value.toString()
  }

  get symbol(): string {
    return this._event.parameters[1].value.toString()
  }

  get decimals(): i32 {
    return this._event.parameters[2].value.toI32()
  }
}

export class Approval extends ethereum.Event {
  get params(): Approval__Params {
    return new Approval__Params(this)
  }
}

export class Approval__Params {
  _event: Approval

  constructor(event: Approval) {
    this._event = event
  }

  get owner(): Address {
    return this._event.parameters[0].value.toAddress()
  }

  get spender(): Address {
    return this._event.parameters[1].value.toAddress()
  }

  get value(): BigInt {
    return this._event.parameters[2].value.toBigInt()
  }
}

export class ClaimDealTokens extends ethereum.Event {
  get params(): ClaimDealTokens__Params {
    return new ClaimDealTokens__Params(this)
  }
}

export class ClaimDealTokens__Params {
  _event: ClaimDealTokens

  constructor(event: ClaimDealTokens) {
    this._event = event
  }

  get user(): Address {
    return this._event.parameters[0].value.toAddress()
  }

  get amountMinted(): BigInt {
    return this._event.parameters[1].value.toBigInt()
  }

  get amountPurchasingReturned(): BigInt {
    return this._event.parameters[2].value.toBigInt()
  }
}

export class ClaimedUnderlyingDealToken extends ethereum.Event {
  get params(): ClaimedUnderlyingDealToken__Params {
    return new ClaimedUnderlyingDealToken__Params(this)
  }
}

export class ClaimedUnderlyingDealToken__Params {
  _event: ClaimedUnderlyingDealToken

  constructor(event: ClaimedUnderlyingDealToken) {
    this._event = event
  }

  get user(): Address {
    return this._event.parameters[0].value.toAddress()
  }

  get underlyingToken(): Address {
    return this._event.parameters[1].value.toAddress()
  }

  get amountClaimed(): BigInt {
    return this._event.parameters[2].value.toBigInt()
  }
}

export class CreateUpFrontDeal extends ethereum.Event {
  get params(): CreateUpFrontDeal__Params {
    return new CreateUpFrontDeal__Params(this)
  }
}

export class CreateUpFrontDeal__Params {
  _event: CreateUpFrontDeal

  constructor(event: CreateUpFrontDeal) {
    this._event = event
  }

  get dealAddress(): Address {
    return this._event.parameters[0].value.toAddress()
  }

  get name(): string {
    return this._event.parameters[1].value.toString()
  }

  get symbol(): string {
    return this._event.parameters[2].value.toString()
  }

  get purchaseToken(): Address {
    return this._event.parameters[3].value.toAddress()
  }

  get underlyingDealToken(): Address {
    return this._event.parameters[4].value.toAddress()
  }

  get holder(): Address {
    return this._event.parameters[5].value.toAddress()
  }

  get sponsor(): Address {
    return this._event.parameters[6].value.toAddress()
  }

  get sponsorFee(): BigInt {
    return this._event.parameters[7].value.toBigInt()
  }

  get merkleRoot(): Bytes {
    return this._event.parameters[8].value.toBytes()
  }

  get ipfsHash(): string {
    return this._event.parameters[9].value.toString()
  }
}

export class CreateUpFrontDealConfig extends ethereum.Event {
  get params(): CreateUpFrontDealConfig__Params {
    return new CreateUpFrontDealConfig__Params(this)
  }
}

export class CreateUpFrontDealConfig__Params {
  _event: CreateUpFrontDealConfig

  constructor(event: CreateUpFrontDealConfig) {
    this._event = event
  }

  get dealAddress(): Address {
    return this._event.parameters[0].value.toAddress()
  }

  get underlyingDealTokenTotal(): BigInt {
    return this._event.parameters[1].value.toBigInt()
  }

  get purchaseTokenPerDealToken(): BigInt {
    return this._event.parameters[2].value.toBigInt()
  }

  get purchaseRaiseMinimum(): BigInt {
    return this._event.parameters[3].value.toBigInt()
  }

  get purchaseDuration(): BigInt {
    return this._event.parameters[4].value.toBigInt()
  }

  get vestingPeriod(): BigInt {
    return this._event.parameters[5].value.toBigInt()
  }

  get vestingCliffPeriod(): BigInt {
    return this._event.parameters[6].value.toBigInt()
  }

  get allowDeallocation(): boolean {
    return this._event.parameters[7].value.toBoolean()
  }
}

export class DealFullyFunded extends ethereum.Event {
  get params(): DealFullyFunded__Params {
    return new DealFullyFunded__Params(this)
  }
}

export class DealFullyFunded__Params {
  _event: DealFullyFunded

  constructor(event: DealFullyFunded) {
    this._event = event
  }

  get upFrontDealAddress(): Address {
    return this._event.parameters[0].value.toAddress()
  }

  get timestamp(): BigInt {
    return this._event.parameters[1].value.toBigInt()
  }

  get purchaseExpiryTimestamp(): BigInt {
    return this._event.parameters[2].value.toBigInt()
  }

  get vestingCliffExpiryTimestamp(): BigInt {
    return this._event.parameters[3].value.toBigInt()
  }

  get vestingExpiryTimestamp(): BigInt {
    return this._event.parameters[4].value.toBigInt()
  }
}

export class DepositDealToken extends ethereum.Event {
  get params(): DepositDealToken__Params {
    return new DepositDealToken__Params(this)
  }
}

export class DepositDealToken__Params {
  _event: DepositDealToken

  constructor(event: DepositDealToken) {
    this._event = event
  }

  get underlyingDealTokenAddress(): Address {
    return this._event.parameters[0].value.toAddress()
  }

  get depositor(): Address {
    return this._event.parameters[1].value.toAddress()
  }

  get underlyingDealTokenAmount(): BigInt {
    return this._event.parameters[2].value.toBigInt()
  }
}

export class Disavow extends ethereum.Event {
  get params(): Disavow__Params {
    return new Disavow__Params(this)
  }
}

export class Disavow__Params {
  _event: Disavow

  constructor(event: Disavow) {
    this._event = event
  }

  get voucher(): Address {
    return this._event.parameters[0].value.toAddress()
  }
}

export class FeeEscrowClaim extends ethereum.Event {
  get params(): FeeEscrowClaim__Params {
    return new FeeEscrowClaim__Params(this)
  }
}

export class FeeEscrowClaim__Params {
  _event: FeeEscrowClaim

  constructor(event: FeeEscrowClaim) {
    this._event = event
  }

  get aelinFeeEscrow(): Address {
    return this._event.parameters[0].value.toAddress()
  }

  get underlyingTokenAddress(): Address {
    return this._event.parameters[1].value.toAddress()
  }

  get amount(): BigInt {
    return this._event.parameters[2].value.toBigInt()
  }
}

export class HolderClaim extends ethereum.Event {
  get params(): HolderClaim__Params {
    return new HolderClaim__Params(this)
  }
}

export class HolderClaim__Params {
  _event: HolderClaim

  constructor(event: HolderClaim) {
    this._event = event
  }

  get holder(): Address {
    return this._event.parameters[0].value.toAddress()
  }

  get purchaseToken(): Address {
    return this._event.parameters[1].value.toAddress()
  }

  get amountClaimed(): BigInt {
    return this._event.parameters[2].value.toBigInt()
  }

  get underlyingToken(): Address {
    return this._event.parameters[3].value.toAddress()
  }

  get underlyingRefund(): BigInt {
    return this._event.parameters[4].value.toBigInt()
  }

  get timestamp(): BigInt {
    return this._event.parameters[5].value.toBigInt()
  }
}

export class PoolWith1155 extends ethereum.Event {
  get params(): PoolWith1155__Params {
    return new PoolWith1155__Params(this)
  }
}

export class PoolWith1155__Params {
  _event: PoolWith1155

  constructor(event: PoolWith1155) {
    this._event = event
  }

  get collectionAddress(): Address {
    return this._event.parameters[0].value.toAddress()
  }

  get purchaseAmount(): BigInt {
    return this._event.parameters[1].value.toBigInt()
  }

  get purchaseAmountPerToken(): boolean {
    return this._event.parameters[2].value.toBoolean()
  }

  get tokenIds(): Array<BigInt> {
    return this._event.parameters[3].value.toBigIntArray()
  }

  get minTokensEligible(): Array<BigInt> {
    return this._event.parameters[4].value.toBigIntArray()
  }
}

export class PoolWith721 extends ethereum.Event {
  get params(): PoolWith721__Params {
    return new PoolWith721__Params(this)
  }
}

export class PoolWith721__Params {
  _event: PoolWith721

  constructor(event: PoolWith721) {
    this._event = event
  }

  get collectionAddress(): Address {
    return this._event.parameters[0].value.toAddress()
  }

  get purchaseAmount(): BigInt {
    return this._event.parameters[1].value.toBigInt()
  }

  get purchaseAmountPerToken(): boolean {
    return this._event.parameters[2].value.toBoolean()
  }
}

export class SetHolder extends ethereum.Event {
  get params(): SetHolder__Params {
    return new SetHolder__Params(this)
  }
}

export class SetHolder__Params {
  _event: SetHolder

  constructor(event: SetHolder) {
    this._event = event
  }

  get holder(): Address {
    return this._event.parameters[0].value.toAddress()
  }
}

export class SponsorClaim extends ethereum.Event {
  get params(): SponsorClaim__Params {
    return new SponsorClaim__Params(this)
  }
}

export class SponsorClaim__Params {
  _event: SponsorClaim

  constructor(event: SponsorClaim) {
    this._event = event
  }

  get sponsor(): Address {
    return this._event.parameters[0].value.toAddress()
  }

  get amountMinted(): BigInt {
    return this._event.parameters[1].value.toBigInt()
  }
}

export class Transfer extends ethereum.Event {
  get params(): Transfer__Params {
    return new Transfer__Params(this)
  }
}

export class Transfer__Params {
  _event: Transfer

  constructor(event: Transfer) {
    this._event = event
  }

  get from(): Address {
    return this._event.parameters[0].value.toAddress()
  }

  get to(): Address {
    return this._event.parameters[1].value.toAddress()
  }

  get value(): BigInt {
    return this._event.parameters[2].value.toBigInt()
  }
}

export class Vouch extends ethereum.Event {
  get params(): Vouch__Params {
    return new Vouch__Params(this)
  }
}

export class Vouch__Params {
  _event: Vouch

  constructor(event: Vouch) {
    this._event = event
  }

  get voucher(): Address {
    return this._event.parameters[0].value.toAddress()
  }
}

export class WithdrewExcess extends ethereum.Event {
  get params(): WithdrewExcess__Params {
    return new WithdrewExcess__Params(this)
  }
}

export class WithdrewExcess__Params {
  _event: WithdrewExcess

  constructor(event: WithdrewExcess) {
    this._event = event
  }

  get UpFrontDealAddress(): Address {
    return this._event.parameters[0].value.toAddress()
  }

  get amountWithdrawn(): BigInt {
    return this._event.parameters[1].value.toBigInt()
  }
}

export class AelinUpfrontDeal__dealConfigResult {
  value0: BigInt
  value1: BigInt
  value2: BigInt
  value3: BigInt
  value4: BigInt
  value5: BigInt
  value6: boolean

  constructor(
    value0: BigInt,
    value1: BigInt,
    value2: BigInt,
    value3: BigInt,
    value4: BigInt,
    value5: BigInt,
    value6: boolean,
  ) {
    this.value0 = value0
    this.value1 = value1
    this.value2 = value2
    this.value3 = value3
    this.value4 = value4
    this.value5 = value5
    this.value6 = value6
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>()
    map.set('value0', ethereum.Value.fromUnsignedBigInt(this.value0))
    map.set('value1', ethereum.Value.fromUnsignedBigInt(this.value1))
    map.set('value2', ethereum.Value.fromUnsignedBigInt(this.value2))
    map.set('value3', ethereum.Value.fromUnsignedBigInt(this.value3))
    map.set('value4', ethereum.Value.fromUnsignedBigInt(this.value4))
    map.set('value5', ethereum.Value.fromUnsignedBigInt(this.value5))
    map.set('value6', ethereum.Value.fromBoolean(this.value6))
    return map
  }
}

export class AelinUpfrontDeal__dealDataResult {
  value0: string
  value1: string
  value2: Address
  value3: Address
  value4: Address
  value5: Address
  value6: BigInt
  value7: Bytes
  value8: string

  constructor(
    value0: string,
    value1: string,
    value2: Address,
    value3: Address,
    value4: Address,
    value5: Address,
    value6: BigInt,
    value7: Bytes,
    value8: string,
  ) {
    this.value0 = value0
    this.value1 = value1
    this.value2 = value2
    this.value3 = value3
    this.value4 = value4
    this.value5 = value5
    this.value6 = value6
    this.value7 = value7
    this.value8 = value8
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>()
    map.set('value0', ethereum.Value.fromString(this.value0))
    map.set('value1', ethereum.Value.fromString(this.value1))
    map.set('value2', ethereum.Value.fromAddress(this.value2))
    map.set('value3', ethereum.Value.fromAddress(this.value3))
    map.set('value4', ethereum.Value.fromAddress(this.value4))
    map.set('value5', ethereum.Value.fromAddress(this.value5))
    map.set('value6', ethereum.Value.fromUnsignedBigInt(this.value6))
    map.set('value7', ethereum.Value.fromFixedBytes(this.value7))
    map.set('value8', ethereum.Value.fromString(this.value8))
    return map
  }
}

export class AelinUpfrontDeal__getAllowListResult {
  value0: Array<Address>
  value1: Array<BigInt>
  value2: BigInt
  value3: boolean

  constructor(value0: Array<Address>, value1: Array<BigInt>, value2: BigInt, value3: boolean) {
    this.value0 = value0
    this.value1 = value1
    this.value2 = value2
    this.value3 = value3
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>()
    map.set('value0', ethereum.Value.fromAddressArray(this.value0))
    map.set('value1', ethereum.Value.fromUnsignedBigIntArray(this.value1))
    map.set('value2', ethereum.Value.fromUnsignedBigInt(this.value2))
    map.set('value3', ethereum.Value.fromBoolean(this.value3))
    return map
  }
}

export class AelinUpfrontDeal__getNftCollectionDetailsResult {
  value0: BigInt
  value1: Address
  value2: boolean
  value3: Array<BigInt>
  value4: Array<BigInt>

  constructor(
    value0: BigInt,
    value1: Address,
    value2: boolean,
    value3: Array<BigInt>,
    value4: Array<BigInt>,
  ) {
    this.value0 = value0
    this.value1 = value1
    this.value2 = value2
    this.value3 = value3
    this.value4 = value4
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>()
    map.set('value0', ethereum.Value.fromUnsignedBigInt(this.value0))
    map.set('value1', ethereum.Value.fromAddress(this.value1))
    map.set('value2', ethereum.Value.fromBoolean(this.value2))
    map.set('value3', ethereum.Value.fromUnsignedBigIntArray(this.value3))
    map.set('value4', ethereum.Value.fromUnsignedBigIntArray(this.value4))
    return map
  }
}

export class AelinUpfrontDeal__getNftGatingDetailsResult {
  value0: boolean
  value1: boolean
  value2: boolean

  constructor(value0: boolean, value1: boolean, value2: boolean) {
    this.value0 = value0
    this.value1 = value1
    this.value2 = value2
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>()
    map.set('value0', ethereum.Value.fromBoolean(this.value0))
    map.set('value1', ethereum.Value.fromBoolean(this.value1))
    map.set('value2', ethereum.Value.fromBoolean(this.value2))
    return map
  }
}

export class AelinUpfrontDeal extends ethereum.SmartContract {
  static bind(address: Address): AelinUpfrontDeal {
    return new AelinUpfrontDeal('AelinUpfrontDeal', address)
  }

  aelinEscrowLogicAddress(): Address {
    let result = super.call('aelinEscrowLogicAddress', 'aelinEscrowLogicAddress():(address)', [])

    return result[0].toAddress()
  }

  try_aelinEscrowLogicAddress(): ethereum.CallResult<Address> {
    let result = super.tryCall('aelinEscrowLogicAddress', 'aelinEscrowLogicAddress():(address)', [])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toAddress())
  }

  aelinFeeEscrow(): Address {
    let result = super.call('aelinFeeEscrow', 'aelinFeeEscrow():(address)', [])

    return result[0].toAddress()
  }

  try_aelinFeeEscrow(): ethereum.CallResult<Address> {
    let result = super.tryCall('aelinFeeEscrow', 'aelinFeeEscrow():(address)', [])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toAddress())
  }

  aelinTreasuryAddress(): Address {
    let result = super.call('aelinTreasuryAddress', 'aelinTreasuryAddress():(address)', [])

    return result[0].toAddress()
  }

  try_aelinTreasuryAddress(): ethereum.CallResult<Address> {
    let result = super.tryCall('aelinTreasuryAddress', 'aelinTreasuryAddress():(address)', [])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toAddress())
  }

  allowList(): boolean {
    let result = super.call('allowList', 'allowList():(bool)', [])

    return result[0].toBoolean()
  }

  try_allowList(): ethereum.CallResult<boolean> {
    let result = super.tryCall('allowList', 'allowList():(bool)', [])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toBoolean())
  }

  allowance(owner: Address, spender: Address): BigInt {
    let result = super.call('allowance', 'allowance(address,address):(uint256)', [
      ethereum.Value.fromAddress(owner),
      ethereum.Value.fromAddress(spender),
    ])

    return result[0].toBigInt()
  }

  try_allowance(owner: Address, spender: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall('allowance', 'allowance(address,address):(uint256)', [
      ethereum.Value.fromAddress(owner),
      ethereum.Value.fromAddress(spender),
    ])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toBigInt())
  }

  amountVested(param0: Address): BigInt {
    let result = super.call('amountVested', 'amountVested(address):(uint256)', [
      ethereum.Value.fromAddress(param0),
    ])

    return result[0].toBigInt()
  }

  try_amountVested(param0: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall('amountVested', 'amountVested(address):(uint256)', [
      ethereum.Value.fromAddress(param0),
    ])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toBigInt())
  }

  approve(spender: Address, amount: BigInt): boolean {
    let result = super.call('approve', 'approve(address,uint256):(bool)', [
      ethereum.Value.fromAddress(spender),
      ethereum.Value.fromUnsignedBigInt(amount),
    ])

    return result[0].toBoolean()
  }

  try_approve(spender: Address, amount: BigInt): ethereum.CallResult<boolean> {
    let result = super.tryCall('approve', 'approve(address,uint256):(bool)', [
      ethereum.Value.fromAddress(spender),
      ethereum.Value.fromUnsignedBigInt(amount),
    ])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toBoolean())
  }

  balanceOf(account: Address): BigInt {
    let result = super.call('balanceOf', 'balanceOf(address):(uint256)', [
      ethereum.Value.fromAddress(account),
    ])

    return result[0].toBigInt()
  }

  try_balanceOf(account: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall('balanceOf', 'balanceOf(address):(uint256)', [
      ethereum.Value.fromAddress(account),
    ])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toBigInt())
  }

  claimableUnderlyingTokens(_purchaser: Address): BigInt {
    let result = super.call(
      'claimableUnderlyingTokens',
      'claimableUnderlyingTokens(address):(uint256)',
      [ethereum.Value.fromAddress(_purchaser)],
    )

    return result[0].toBigInt()
  }

  try_claimableUnderlyingTokens(_purchaser: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      'claimableUnderlyingTokens',
      'claimableUnderlyingTokens(address):(uint256)',
      [ethereum.Value.fromAddress(_purchaser)],
    )
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toBigInt())
  }

  dealConfig(): AelinUpfrontDeal__dealConfigResult {
    let result = super.call(
      'dealConfig',
      'dealConfig():(uint256,uint256,uint256,uint256,uint256,uint256,bool)',
      [],
    )

    return new AelinUpfrontDeal__dealConfigResult(
      result[0].toBigInt(),
      result[1].toBigInt(),
      result[2].toBigInt(),
      result[3].toBigInt(),
      result[4].toBigInt(),
      result[5].toBigInt(),
      result[6].toBoolean(),
    )
  }

  try_dealConfig(): ethereum.CallResult<AelinUpfrontDeal__dealConfigResult> {
    let result = super.tryCall(
      'dealConfig',
      'dealConfig():(uint256,uint256,uint256,uint256,uint256,uint256,bool)',
      [],
    )
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(
      new AelinUpfrontDeal__dealConfigResult(
        value[0].toBigInt(),
        value[1].toBigInt(),
        value[2].toBigInt(),
        value[3].toBigInt(),
        value[4].toBigInt(),
        value[5].toBigInt(),
        value[6].toBoolean(),
      ),
    )
  }

  dealData(): AelinUpfrontDeal__dealDataResult {
    let result = super.call(
      'dealData',
      'dealData():(string,string,address,address,address,address,uint256,bytes32,string)',
      [],
    )

    return new AelinUpfrontDeal__dealDataResult(
      result[0].toString(),
      result[1].toString(),
      result[2].toAddress(),
      result[3].toAddress(),
      result[4].toAddress(),
      result[5].toAddress(),
      result[6].toBigInt(),
      result[7].toBytes(),
      result[8].toString(),
    )
  }

  try_dealData(): ethereum.CallResult<AelinUpfrontDeal__dealDataResult> {
    let result = super.tryCall(
      'dealData',
      'dealData():(string,string,address,address,address,address,uint256,bytes32,string)',
      [],
    )
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(
      new AelinUpfrontDeal__dealDataResult(
        value[0].toString(),
        value[1].toString(),
        value[2].toAddress(),
        value[3].toAddress(),
        value[4].toAddress(),
        value[5].toAddress(),
        value[6].toBigInt(),
        value[7].toBytes(),
        value[8].toString(),
      ),
    )
  }

  dealFactory(): Address {
    let result = super.call('dealFactory', 'dealFactory():(address)', [])

    return result[0].toAddress()
  }

  try_dealFactory(): ethereum.CallResult<Address> {
    let result = super.tryCall('dealFactory', 'dealFactory():(address)', [])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toAddress())
  }

  dealStart(): BigInt {
    let result = super.call('dealStart', 'dealStart():(uint256)', [])

    return result[0].toBigInt()
  }

  try_dealStart(): ethereum.CallResult<BigInt> {
    let result = super.tryCall('dealStart', 'dealStart():(uint256)', [])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toBigInt())
  }

  decimals(): i32 {
    let result = super.call('decimals', 'decimals():(uint8)', [])

    return result[0].toI32()
  }

  try_decimals(): ethereum.CallResult<i32> {
    let result = super.tryCall('decimals', 'decimals():(uint8)', [])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toI32())
  }

  decreaseAllowance(spender: Address, subtractedValue: BigInt): boolean {
    let result = super.call('decreaseAllowance', 'decreaseAllowance(address,uint256):(bool)', [
      ethereum.Value.fromAddress(spender),
      ethereum.Value.fromUnsignedBigInt(subtractedValue),
    ])

    return result[0].toBoolean()
  }

  try_decreaseAllowance(spender: Address, subtractedValue: BigInt): ethereum.CallResult<boolean> {
    let result = super.tryCall('decreaseAllowance', 'decreaseAllowance(address,uint256):(bool)', [
      ethereum.Value.fromAddress(spender),
      ethereum.Value.fromUnsignedBigInt(subtractedValue),
    ])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toBoolean())
  }

  futureHolder(): Address {
    let result = super.call('futureHolder', 'futureHolder():(address)', [])

    return result[0].toAddress()
  }

  try_futureHolder(): ethereum.CallResult<Address> {
    let result = super.tryCall('futureHolder', 'futureHolder():(address)', [])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toAddress())
  }

  getAllowList(_userAddress: Address): AelinUpfrontDeal__getAllowListResult {
    let result = super.call(
      'getAllowList',
      'getAllowList(address):(address[],uint256[],uint256,bool)',
      [ethereum.Value.fromAddress(_userAddress)],
    )

    return new AelinUpfrontDeal__getAllowListResult(
      result[0].toAddressArray(),
      result[1].toBigIntArray(),
      result[2].toBigInt(),
      result[3].toBoolean(),
    )
  }

  try_getAllowList(
    _userAddress: Address,
  ): ethereum.CallResult<AelinUpfrontDeal__getAllowListResult> {
    let result = super.tryCall(
      'getAllowList',
      'getAllowList(address):(address[],uint256[],uint256,bool)',
      [ethereum.Value.fromAddress(_userAddress)],
    )
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(
      new AelinUpfrontDeal__getAllowListResult(
        value[0].toAddressArray(),
        value[1].toBigIntArray(),
        value[2].toBigInt(),
        value[3].toBoolean(),
      ),
    )
  }

  getAmountVested(_address: Address): BigInt {
    let result = super.call('getAmountVested', 'getAmountVested(address):(uint256)', [
      ethereum.Value.fromAddress(_address),
    ])

    return result[0].toBigInt()
  }

  try_getAmountVested(_address: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall('getAmountVested', 'getAmountVested(address):(uint256)', [
      ethereum.Value.fromAddress(_address),
    ])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toBigInt())
  }

  getNftCollectionDetails(_collection: Address): AelinUpfrontDeal__getNftCollectionDetailsResult {
    let result = super.call(
      'getNftCollectionDetails',
      'getNftCollectionDetails(address):(uint256,address,bool,uint256[],uint256[])',
      [ethereum.Value.fromAddress(_collection)],
    )

    return new AelinUpfrontDeal__getNftCollectionDetailsResult(
      result[0].toBigInt(),
      result[1].toAddress(),
      result[2].toBoolean(),
      result[3].toBigIntArray(),
      result[4].toBigIntArray(),
    )
  }

  try_getNftCollectionDetails(
    _collection: Address,
  ): ethereum.CallResult<AelinUpfrontDeal__getNftCollectionDetailsResult> {
    let result = super.tryCall(
      'getNftCollectionDetails',
      'getNftCollectionDetails(address):(uint256,address,bool,uint256[],uint256[])',
      [ethereum.Value.fromAddress(_collection)],
    )
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(
      new AelinUpfrontDeal__getNftCollectionDetailsResult(
        value[0].toBigInt(),
        value[1].toAddress(),
        value[2].toBoolean(),
        value[3].toBigIntArray(),
        value[4].toBigIntArray(),
      ),
    )
  }

  getNftGatingDetails(
    _collection: Address,
    _wallet: Address,
    _nftId: BigInt,
  ): AelinUpfrontDeal__getNftGatingDetailsResult {
    let result = super.call(
      'getNftGatingDetails',
      'getNftGatingDetails(address,address,uint256):(bool,bool,bool)',
      [
        ethereum.Value.fromAddress(_collection),
        ethereum.Value.fromAddress(_wallet),
        ethereum.Value.fromUnsignedBigInt(_nftId),
      ],
    )

    return new AelinUpfrontDeal__getNftGatingDetailsResult(
      result[0].toBoolean(),
      result[1].toBoolean(),
      result[2].toBoolean(),
    )
  }

  try_getNftGatingDetails(
    _collection: Address,
    _wallet: Address,
    _nftId: BigInt,
  ): ethereum.CallResult<AelinUpfrontDeal__getNftGatingDetailsResult> {
    let result = super.tryCall(
      'getNftGatingDetails',
      'getNftGatingDetails(address,address,uint256):(bool,bool,bool)',
      [
        ethereum.Value.fromAddress(_collection),
        ethereum.Value.fromAddress(_wallet),
        ethereum.Value.fromUnsignedBigInt(_nftId),
      ],
    )
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(
      new AelinUpfrontDeal__getNftGatingDetailsResult(
        value[0].toBoolean(),
        value[1].toBoolean(),
        value[2].toBoolean(),
      ),
    )
  }

  getPoolSharesPerUser(_address: Address): BigInt {
    let result = super.call('getPoolSharesPerUser', 'getPoolSharesPerUser(address):(uint256)', [
      ethereum.Value.fromAddress(_address),
    ])

    return result[0].toBigInt()
  }

  try_getPoolSharesPerUser(_address: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall('getPoolSharesPerUser', 'getPoolSharesPerUser(address):(uint256)', [
      ethereum.Value.fromAddress(_address),
    ])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toBigInt())
  }

  getPurchaseTokensPerUser(_address: Address): BigInt {
    let result = super.call(
      'getPurchaseTokensPerUser',
      'getPurchaseTokensPerUser(address):(uint256)',
      [ethereum.Value.fromAddress(_address)],
    )

    return result[0].toBigInt()
  }

  try_getPurchaseTokensPerUser(_address: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      'getPurchaseTokensPerUser',
      'getPurchaseTokensPerUser(address):(uint256)',
      [ethereum.Value.fromAddress(_address)],
    )
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toBigInt())
  }

  hasPurchasedMerkle(_index: BigInt): boolean {
    let result = super.call('hasPurchasedMerkle', 'hasPurchasedMerkle(uint256):(bool)', [
      ethereum.Value.fromUnsignedBigInt(_index),
    ])

    return result[0].toBoolean()
  }

  try_hasPurchasedMerkle(_index: BigInt): ethereum.CallResult<boolean> {
    let result = super.tryCall('hasPurchasedMerkle', 'hasPurchasedMerkle(uint256):(bool)', [
      ethereum.Value.fromUnsignedBigInt(_index),
    ])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toBoolean())
  }

  increaseAllowance(spender: Address, addedValue: BigInt): boolean {
    let result = super.call('increaseAllowance', 'increaseAllowance(address,uint256):(bool)', [
      ethereum.Value.fromAddress(spender),
      ethereum.Value.fromUnsignedBigInt(addedValue),
    ])

    return result[0].toBoolean()
  }

  try_increaseAllowance(spender: Address, addedValue: BigInt): ethereum.CallResult<boolean> {
    let result = super.tryCall('increaseAllowance', 'increaseAllowance(address,uint256):(bool)', [
      ethereum.Value.fromAddress(spender),
      ethereum.Value.fromUnsignedBigInt(addedValue),
    ])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toBoolean())
  }

  name(): string {
    let result = super.call('name', 'name():(string)', [])

    return result[0].toString()
  }

  try_name(): ethereum.CallResult<string> {
    let result = super.tryCall('name', 'name():(string)', [])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toString())
  }

  nftGating(): boolean {
    let result = super.call('nftGating', 'nftGating():(bool)', [])

    return result[0].toBoolean()
  }

  try_nftGating(): ethereum.CallResult<boolean> {
    let result = super.tryCall('nftGating', 'nftGating():(bool)', [])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toBoolean())
  }

  poolSharesPerUser(param0: Address): BigInt {
    let result = super.call('poolSharesPerUser', 'poolSharesPerUser(address):(uint256)', [
      ethereum.Value.fromAddress(param0),
    ])

    return result[0].toBigInt()
  }

  try_poolSharesPerUser(param0: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall('poolSharesPerUser', 'poolSharesPerUser(address):(uint256)', [
      ethereum.Value.fromAddress(param0),
    ])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toBigInt())
  }

  purchaseExpiry(): BigInt {
    let result = super.call('purchaseExpiry', 'purchaseExpiry():(uint256)', [])

    return result[0].toBigInt()
  }

  try_purchaseExpiry(): ethereum.CallResult<BigInt> {
    let result = super.tryCall('purchaseExpiry', 'purchaseExpiry():(uint256)', [])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toBigInt())
  }

  purchaseTokensPerUser(param0: Address): BigInt {
    let result = super.call('purchaseTokensPerUser', 'purchaseTokensPerUser(address):(uint256)', [
      ethereum.Value.fromAddress(param0),
    ])

    return result[0].toBigInt()
  }

  try_purchaseTokensPerUser(param0: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      'purchaseTokensPerUser',
      'purchaseTokensPerUser(address):(uint256)',
      [ethereum.Value.fromAddress(param0)],
    )
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toBigInt())
  }

  symbol(): string {
    let result = super.call('symbol', 'symbol():(string)', [])

    return result[0].toString()
  }

  try_symbol(): ethereum.CallResult<string> {
    let result = super.tryCall('symbol', 'symbol():(string)', [])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toString())
  }

  totalPoolShares(): BigInt {
    let result = super.call('totalPoolShares', 'totalPoolShares():(uint256)', [])

    return result[0].toBigInt()
  }

  try_totalPoolShares(): ethereum.CallResult<BigInt> {
    let result = super.tryCall('totalPoolShares', 'totalPoolShares():(uint256)', [])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toBigInt())
  }

  totalPurchasingAccepted(): BigInt {
    let result = super.call('totalPurchasingAccepted', 'totalPurchasingAccepted():(uint256)', [])

    return result[0].toBigInt()
  }

  try_totalPurchasingAccepted(): ethereum.CallResult<BigInt> {
    let result = super.tryCall('totalPurchasingAccepted', 'totalPurchasingAccepted():(uint256)', [])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toBigInt())
  }

  totalSupply(): BigInt {
    let result = super.call('totalSupply', 'totalSupply():(uint256)', [])

    return result[0].toBigInt()
  }

  try_totalSupply(): ethereum.CallResult<BigInt> {
    let result = super.tryCall('totalSupply', 'totalSupply():(uint256)', [])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toBigInt())
  }

  totalUnderlyingClaimed(): BigInt {
    let result = super.call('totalUnderlyingClaimed', 'totalUnderlyingClaimed():(uint256)', [])

    return result[0].toBigInt()
  }

  try_totalUnderlyingClaimed(): ethereum.CallResult<BigInt> {
    let result = super.tryCall('totalUnderlyingClaimed', 'totalUnderlyingClaimed():(uint256)', [])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toBigInt())
  }

  transfer(_dst: Address, _amount: BigInt): boolean {
    let result = super.call('transfer', 'transfer(address,uint256):(bool)', [
      ethereum.Value.fromAddress(_dst),
      ethereum.Value.fromUnsignedBigInt(_amount),
    ])

    return result[0].toBoolean()
  }

  try_transfer(_dst: Address, _amount: BigInt): ethereum.CallResult<boolean> {
    let result = super.tryCall('transfer', 'transfer(address,uint256):(bool)', [
      ethereum.Value.fromAddress(_dst),
      ethereum.Value.fromUnsignedBigInt(_amount),
    ])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toBoolean())
  }

  transferFrom(_src: Address, _dst: Address, _amount: BigInt): boolean {
    let result = super.call('transferFrom', 'transferFrom(address,address,uint256):(bool)', [
      ethereum.Value.fromAddress(_src),
      ethereum.Value.fromAddress(_dst),
      ethereum.Value.fromUnsignedBigInt(_amount),
    ])

    return result[0].toBoolean()
  }

  try_transferFrom(_src: Address, _dst: Address, _amount: BigInt): ethereum.CallResult<boolean> {
    let result = super.tryCall('transferFrom', 'transferFrom(address,address,uint256):(bool)', [
      ethereum.Value.fromAddress(_src),
      ethereum.Value.fromAddress(_dst),
      ethereum.Value.fromUnsignedBigInt(_amount),
    ])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toBoolean())
  }

  vestingCliffExpiry(): BigInt {
    let result = super.call('vestingCliffExpiry', 'vestingCliffExpiry():(uint256)', [])

    return result[0].toBigInt()
  }

  try_vestingCliffExpiry(): ethereum.CallResult<BigInt> {
    let result = super.tryCall('vestingCliffExpiry', 'vestingCliffExpiry():(uint256)', [])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toBigInt())
  }

  vestingExpiry(): BigInt {
    let result = super.call('vestingExpiry', 'vestingExpiry():(uint256)', [])

    return result[0].toBigInt()
  }

  try_vestingExpiry(): ethereum.CallResult<BigInt> {
    let result = super.tryCall('vestingExpiry', 'vestingExpiry():(uint256)', [])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toBigInt())
  }
}

export class AcceptDealCall extends ethereum.Call {
  get inputs(): AcceptDealCall__Inputs {
    return new AcceptDealCall__Inputs(this)
  }

  get outputs(): AcceptDealCall__Outputs {
    return new AcceptDealCall__Outputs(this)
  }
}

export class AcceptDealCall__Inputs {
  _call: AcceptDealCall

  constructor(call: AcceptDealCall) {
    this._call = call
  }

  get _nftPurchaseList(): Array<AcceptDealCall_nftPurchaseListStruct> {
    return this._call.inputValues[0].value.toTupleArray<AcceptDealCall_nftPurchaseListStruct>()
  }

  get _merkleData(): AcceptDealCall_merkleDataStruct {
    return changetype<AcceptDealCall_merkleDataStruct>(this._call.inputValues[1].value.toTuple())
  }

  get _purchaseTokenAmount(): BigInt {
    return this._call.inputValues[2].value.toBigInt()
  }
}

export class AcceptDealCall__Outputs {
  _call: AcceptDealCall

  constructor(call: AcceptDealCall) {
    this._call = call
  }
}

export class AcceptDealCall_nftPurchaseListStruct extends ethereum.Tuple {
  get collectionAddress(): Address {
    return this[0].toAddress()
  }

  get tokenIds(): Array<BigInt> {
    return this[1].toBigIntArray()
  }
}

export class AcceptDealCall_merkleDataStruct extends ethereum.Tuple {
  get index(): BigInt {
    return this[0].toBigInt()
  }

  get account(): Address {
    return this[1].toAddress()
  }

  get amount(): BigInt {
    return this[2].toBigInt()
  }

  get merkleProof(): Array<Bytes> {
    return this[3].toBytesArray()
  }
}

export class AcceptHolderCall extends ethereum.Call {
  get inputs(): AcceptHolderCall__Inputs {
    return new AcceptHolderCall__Inputs(this)
  }

  get outputs(): AcceptHolderCall__Outputs {
    return new AcceptHolderCall__Outputs(this)
  }
}

export class AcceptHolderCall__Inputs {
  _call: AcceptHolderCall

  constructor(call: AcceptHolderCall) {
    this._call = call
  }
}

export class AcceptHolderCall__Outputs {
  _call: AcceptHolderCall

  constructor(call: AcceptHolderCall) {
    this._call = call
  }
}

export class ApproveCall extends ethereum.Call {
  get inputs(): ApproveCall__Inputs {
    return new ApproveCall__Inputs(this)
  }

  get outputs(): ApproveCall__Outputs {
    return new ApproveCall__Outputs(this)
  }
}

export class ApproveCall__Inputs {
  _call: ApproveCall

  constructor(call: ApproveCall) {
    this._call = call
  }

  get spender(): Address {
    return this._call.inputValues[0].value.toAddress()
  }

  get amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt()
  }
}

export class ApproveCall__Outputs {
  _call: ApproveCall

  constructor(call: ApproveCall) {
    this._call = call
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean()
  }
}

export class ClaimUnderlyingCall extends ethereum.Call {
  get inputs(): ClaimUnderlyingCall__Inputs {
    return new ClaimUnderlyingCall__Inputs(this)
  }

  get outputs(): ClaimUnderlyingCall__Outputs {
    return new ClaimUnderlyingCall__Outputs(this)
  }
}

export class ClaimUnderlyingCall__Inputs {
  _call: ClaimUnderlyingCall

  constructor(call: ClaimUnderlyingCall) {
    this._call = call
  }
}

export class ClaimUnderlyingCall__Outputs {
  _call: ClaimUnderlyingCall

  constructor(call: ClaimUnderlyingCall) {
    this._call = call
  }
}

export class DecreaseAllowanceCall extends ethereum.Call {
  get inputs(): DecreaseAllowanceCall__Inputs {
    return new DecreaseAllowanceCall__Inputs(this)
  }

  get outputs(): DecreaseAllowanceCall__Outputs {
    return new DecreaseAllowanceCall__Outputs(this)
  }
}

export class DecreaseAllowanceCall__Inputs {
  _call: DecreaseAllowanceCall

  constructor(call: DecreaseAllowanceCall) {
    this._call = call
  }

  get spender(): Address {
    return this._call.inputValues[0].value.toAddress()
  }

  get subtractedValue(): BigInt {
    return this._call.inputValues[1].value.toBigInt()
  }
}

export class DecreaseAllowanceCall__Outputs {
  _call: DecreaseAllowanceCall

  constructor(call: DecreaseAllowanceCall) {
    this._call = call
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean()
  }
}

export class DepositUnderlyingTokensCall extends ethereum.Call {
  get inputs(): DepositUnderlyingTokensCall__Inputs {
    return new DepositUnderlyingTokensCall__Inputs(this)
  }

  get outputs(): DepositUnderlyingTokensCall__Outputs {
    return new DepositUnderlyingTokensCall__Outputs(this)
  }
}

export class DepositUnderlyingTokensCall__Inputs {
  _call: DepositUnderlyingTokensCall

  constructor(call: DepositUnderlyingTokensCall) {
    this._call = call
  }

  get _depositUnderlyingAmount(): BigInt {
    return this._call.inputValues[0].value.toBigInt()
  }
}

export class DepositUnderlyingTokensCall__Outputs {
  _call: DepositUnderlyingTokensCall

  constructor(call: DepositUnderlyingTokensCall) {
    this._call = call
  }
}

export class DisavowCall extends ethereum.Call {
  get inputs(): DisavowCall__Inputs {
    return new DisavowCall__Inputs(this)
  }

  get outputs(): DisavowCall__Outputs {
    return new DisavowCall__Outputs(this)
  }
}

export class DisavowCall__Inputs {
  _call: DisavowCall

  constructor(call: DisavowCall) {
    this._call = call
  }
}

export class DisavowCall__Outputs {
  _call: DisavowCall

  constructor(call: DisavowCall) {
    this._call = call
  }
}

export class FeeEscrowClaimCall extends ethereum.Call {
  get inputs(): FeeEscrowClaimCall__Inputs {
    return new FeeEscrowClaimCall__Inputs(this)
  }

  get outputs(): FeeEscrowClaimCall__Outputs {
    return new FeeEscrowClaimCall__Outputs(this)
  }
}

export class FeeEscrowClaimCall__Inputs {
  _call: FeeEscrowClaimCall

  constructor(call: FeeEscrowClaimCall) {
    this._call = call
  }
}

export class FeeEscrowClaimCall__Outputs {
  _call: FeeEscrowClaimCall

  constructor(call: FeeEscrowClaimCall) {
    this._call = call
  }
}

export class HolderClaimCall extends ethereum.Call {
  get inputs(): HolderClaimCall__Inputs {
    return new HolderClaimCall__Inputs(this)
  }

  get outputs(): HolderClaimCall__Outputs {
    return new HolderClaimCall__Outputs(this)
  }
}

export class HolderClaimCall__Inputs {
  _call: HolderClaimCall

  constructor(call: HolderClaimCall) {
    this._call = call
  }
}

export class HolderClaimCall__Outputs {
  _call: HolderClaimCall

  constructor(call: HolderClaimCall) {
    this._call = call
  }
}

export class IncreaseAllowanceCall extends ethereum.Call {
  get inputs(): IncreaseAllowanceCall__Inputs {
    return new IncreaseAllowanceCall__Inputs(this)
  }

  get outputs(): IncreaseAllowanceCall__Outputs {
    return new IncreaseAllowanceCall__Outputs(this)
  }
}

export class IncreaseAllowanceCall__Inputs {
  _call: IncreaseAllowanceCall

  constructor(call: IncreaseAllowanceCall) {
    this._call = call
  }

  get spender(): Address {
    return this._call.inputValues[0].value.toAddress()
  }

  get addedValue(): BigInt {
    return this._call.inputValues[1].value.toBigInt()
  }
}

export class IncreaseAllowanceCall__Outputs {
  _call: IncreaseAllowanceCall

  constructor(call: IncreaseAllowanceCall) {
    this._call = call
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean()
  }
}

export class InitializeCall extends ethereum.Call {
  get inputs(): InitializeCall__Inputs {
    return new InitializeCall__Inputs(this)
  }

  get outputs(): InitializeCall__Outputs {
    return new InitializeCall__Outputs(this)
  }
}

export class InitializeCall__Inputs {
  _call: InitializeCall

  constructor(call: InitializeCall) {
    this._call = call
  }

  get _dealData(): InitializeCall_dealDataStruct {
    return changetype<InitializeCall_dealDataStruct>(this._call.inputValues[0].value.toTuple())
  }

  get _dealConfig(): InitializeCall_dealConfigStruct {
    return changetype<InitializeCall_dealConfigStruct>(this._call.inputValues[1].value.toTuple())
  }

  get _nftCollectionRules(): Array<InitializeCall_nftCollectionRulesStruct> {
    return this._call.inputValues[2].value.toTupleArray<InitializeCall_nftCollectionRulesStruct>()
  }

  get _allowListInit(): InitializeCall_allowListInitStruct {
    return changetype<InitializeCall_allowListInitStruct>(this._call.inputValues[3].value.toTuple())
  }

  get _aelinTreasuryAddress(): Address {
    return this._call.inputValues[4].value.toAddress()
  }

  get _aelinEscrowLogicAddress(): Address {
    return this._call.inputValues[5].value.toAddress()
  }
}

export class InitializeCall__Outputs {
  _call: InitializeCall

  constructor(call: InitializeCall) {
    this._call = call
  }
}

export class InitializeCall_dealDataStruct extends ethereum.Tuple {
  get name(): string {
    return this[0].toString()
  }

  get symbol(): string {
    return this[1].toString()
  }

  get purchaseToken(): Address {
    return this[2].toAddress()
  }

  get underlyingDealToken(): Address {
    return this[3].toAddress()
  }

  get holder(): Address {
    return this[4].toAddress()
  }

  get sponsor(): Address {
    return this[5].toAddress()
  }

  get sponsorFee(): BigInt {
    return this[6].toBigInt()
  }

  get merkleRoot(): Bytes {
    return this[7].toBytes()
  }

  get ipfsHash(): string {
    return this[8].toString()
  }
}

export class InitializeCall_dealConfigStruct extends ethereum.Tuple {
  get underlyingDealTokenTotal(): BigInt {
    return this[0].toBigInt()
  }

  get purchaseTokenPerDealToken(): BigInt {
    return this[1].toBigInt()
  }

  get purchaseRaiseMinimum(): BigInt {
    return this[2].toBigInt()
  }

  get purchaseDuration(): BigInt {
    return this[3].toBigInt()
  }

  get vestingPeriod(): BigInt {
    return this[4].toBigInt()
  }

  get vestingCliffPeriod(): BigInt {
    return this[5].toBigInt()
  }

  get allowDeallocation(): boolean {
    return this[6].toBoolean()
  }
}

export class InitializeCall_nftCollectionRulesStruct extends ethereum.Tuple {
  get purchaseAmount(): BigInt {
    return this[0].toBigInt()
  }

  get collectionAddress(): Address {
    return this[1].toAddress()
  }

  get purchaseAmountPerToken(): boolean {
    return this[2].toBoolean()
  }

  get tokenIds(): Array<BigInt> {
    return this[3].toBigIntArray()
  }

  get minTokensEligible(): Array<BigInt> {
    return this[4].toBigIntArray()
  }
}

export class InitializeCall_allowListInitStruct extends ethereum.Tuple {
  get allowListAddresses(): Array<Address> {
    return this[0].toAddressArray()
  }

  get allowListAmounts(): Array<BigInt> {
    return this[1].toBigIntArray()
  }
}

export class PurchaserClaimCall extends ethereum.Call {
  get inputs(): PurchaserClaimCall__Inputs {
    return new PurchaserClaimCall__Inputs(this)
  }

  get outputs(): PurchaserClaimCall__Outputs {
    return new PurchaserClaimCall__Outputs(this)
  }
}

export class PurchaserClaimCall__Inputs {
  _call: PurchaserClaimCall

  constructor(call: PurchaserClaimCall) {
    this._call = call
  }
}

export class PurchaserClaimCall__Outputs {
  _call: PurchaserClaimCall

  constructor(call: PurchaserClaimCall) {
    this._call = call
  }
}

export class SetHolderCall extends ethereum.Call {
  get inputs(): SetHolderCall__Inputs {
    return new SetHolderCall__Inputs(this)
  }

  get outputs(): SetHolderCall__Outputs {
    return new SetHolderCall__Outputs(this)
  }
}

export class SetHolderCall__Inputs {
  _call: SetHolderCall

  constructor(call: SetHolderCall) {
    this._call = call
  }

  get _holder(): Address {
    return this._call.inputValues[0].value.toAddress()
  }
}

export class SetHolderCall__Outputs {
  _call: SetHolderCall

  constructor(call: SetHolderCall) {
    this._call = call
  }
}

export class SponsorClaimCall extends ethereum.Call {
  get inputs(): SponsorClaimCall__Inputs {
    return new SponsorClaimCall__Inputs(this)
  }

  get outputs(): SponsorClaimCall__Outputs {
    return new SponsorClaimCall__Outputs(this)
  }
}

export class SponsorClaimCall__Inputs {
  _call: SponsorClaimCall

  constructor(call: SponsorClaimCall) {
    this._call = call
  }
}

export class SponsorClaimCall__Outputs {
  _call: SponsorClaimCall

  constructor(call: SponsorClaimCall) {
    this._call = call
  }
}

export class TransferCall extends ethereum.Call {
  get inputs(): TransferCall__Inputs {
    return new TransferCall__Inputs(this)
  }

  get outputs(): TransferCall__Outputs {
    return new TransferCall__Outputs(this)
  }
}

export class TransferCall__Inputs {
  _call: TransferCall

  constructor(call: TransferCall) {
    this._call = call
  }

  get _dst(): Address {
    return this._call.inputValues[0].value.toAddress()
  }

  get _amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt()
  }
}

export class TransferCall__Outputs {
  _call: TransferCall

  constructor(call: TransferCall) {
    this._call = call
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean()
  }
}

export class TransferFromCall extends ethereum.Call {
  get inputs(): TransferFromCall__Inputs {
    return new TransferFromCall__Inputs(this)
  }

  get outputs(): TransferFromCall__Outputs {
    return new TransferFromCall__Outputs(this)
  }
}

export class TransferFromCall__Inputs {
  _call: TransferFromCall

  constructor(call: TransferFromCall) {
    this._call = call
  }

  get _src(): Address {
    return this._call.inputValues[0].value.toAddress()
  }

  get _dst(): Address {
    return this._call.inputValues[1].value.toAddress()
  }

  get _amount(): BigInt {
    return this._call.inputValues[2].value.toBigInt()
  }
}

export class TransferFromCall__Outputs {
  _call: TransferFromCall

  constructor(call: TransferFromCall) {
    this._call = call
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean()
  }
}

export class VouchCall extends ethereum.Call {
  get inputs(): VouchCall__Inputs {
    return new VouchCall__Inputs(this)
  }

  get outputs(): VouchCall__Outputs {
    return new VouchCall__Outputs(this)
  }
}

export class VouchCall__Inputs {
  _call: VouchCall

  constructor(call: VouchCall) {
    this._call = call
  }
}

export class VouchCall__Outputs {
  _call: VouchCall

  constructor(call: VouchCall) {
    this._call = call
  }
}

export class WithdrawExcessCall extends ethereum.Call {
  get inputs(): WithdrawExcessCall__Inputs {
    return new WithdrawExcessCall__Inputs(this)
  }

  get outputs(): WithdrawExcessCall__Outputs {
    return new WithdrawExcessCall__Outputs(this)
  }
}

export class WithdrawExcessCall__Inputs {
  _call: WithdrawExcessCall

  constructor(call: WithdrawExcessCall) {
    this._call = call
  }
}

export class WithdrawExcessCall__Outputs {
  _call: WithdrawExcessCall

  constructor(call: WithdrawExcessCall) {
    this._call = call
  }
}
