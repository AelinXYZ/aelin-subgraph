enum PoolStatus {
  PoolOpen
  FundingDeal
  DealOpen
}

type PoolCreated @entity {
  " the address of the pool "
  id: ID!

  " represents the pool token name `aePool-${name}` "
  name: String!

  " represents the pool token symbol `aeP-${symbol}` "
  symbol: String!

  " the cap on the amount of purchase tokens in the pool. If 0 - that means uncapped "
  purchaseTokenCap: BigInt!

  " the address of the purchase token "
  purchaseToken: Bytes!

  " the duration of the pool assuming no deal is presented when purchasers can withdraw all of their locked funds "
  duration: BigInt!

  " the fee paid to the sponsor when a purchaser accepts a deal "
  sponsorFee: BigInt!

  " the address of the sponsor for fee payments. only the msg.sender of the createPool method can be the sponsor "
  sponsor: Bytes!

  " the amount of time a purchaser gets to enter. After which the purchase period is locked. "
  purchaseDuration: BigInt!

  " the timestamp a purchaser can no longer enter the pool. After which the purchase period is locked. "
  purchaseExpiry: BigInt!

  " the number of decimals on the purchase token "
  purchaseTokenDecimals: Int

  " the block timestamp when the pool was created"
  timestamp: BigInt!

  " if there is an allow list on the pool "
  hasAllowList: Boolean!

  " the current status of the pool "
  poolStatus: PoolStatus!

  " the total amount of contributions to the pool "
  contributions: BigInt!

  " the address of the current proposed deal on the pool "
  dealAddress: Bytes
}

type TotalPoolsCreated @entity {
  " the id is always just 1 "
  id: ID!

  " the number of pools created - we use this for pagination "
  count: BigInt!
}

type PurchasePoolToken @entity {
  " the transaction hash + event log index of the purchase event "
  id: ID!

  " the address of the pool token purchaser "
  purchaser: Bytes!

  " the address of the pool "
  poolAddress: Bytes!

  " the amount of purchase tokens spent "
  purchaseTokenAmount: BigInt!

  " the timestamp the purchase was made "
  timestamp: BigInt!
}

type WithdrawFromPool @entity {
  " the transaction hash + event log index of the purchase event "
  id: ID!

  " the address of the pool token purchaser "
  purchaser: Bytes!

  " the address of the pool "
  poolAddress: Bytes!

  " the amount of purchase tokens spent "
  purchaseTokenAmount: BigInt!
}

type AcceptDeal @entity {
  " the transaction hash + event log index of the purchase event "
  id: ID!

  " the address of the deal token purchaser "
  purchaser: Bytes!

  " the address of the pool "
  poolAddress: Bytes!

  " the address of the deal "
  dealAddress: Bytes!

  " the fee going to the sponsor "
  sponsorFee: BigInt!

  " the fee going to Aelin stakers "
  aelinFee: BigInt!

  " the amount of pool tokens spent. will also equal the amount of deal tokens received "
  poolTokenAmount: BigInt!
}

type DealCreated @entity {
  " the address of the deal "
  id: ID!

  " the name of the deal "
  name: String!

  " the symbol of the deal "
  symbol: String!

  " the address of the pool "
  poolAddress: Bytes!

  " the address of the sponsor "
  sponsor: Bytes!
}

type DealDetail @entity {
  " the address of the deal "
  id: ID!

  " the underlying deal token address "
  underlyingDealToken: Bytes!

  " the total amount of purchse tokens for the deal "
  purchaseTokenTotalForDeal: BigInt!

  " the total amount of underlying deal tokens available for the deal "
  underlyingDealTokenTotal: BigInt!

  " the vesting period which is linear for all deals in v1 "
  vestingPeriod: BigInt!

  " the vesting cliff after which linear vesting starts "
  vestingCliff: BigInt!

  " the initial period in which a deal can be accepted by the purchaser according to their pro rata ownership of the deal "
  proRataRedemptionPeriod: BigInt!

  " the timestamp when the pro rata redemption period starts "
  proRataRedemptionPeriodStart: BigInt

  " after the pro rata period, anyone who maxxed out their contribution during the pro rata period can now use their remaining pool shares to buy deal tokens until the deal is full "
  openRedemptionPeriod: BigInt!

  " the address of the holder of the underlying deal tokens who is receiving the underlying purchaser tokens "
  holder: Bytes!

  " is the deal fully funded "
  isDealFunded: Boolean!

  " the exipration of the holder funding period "
  holderFundingExpiration: BigInt!

  " the duration of the holder funding period "
  holderFundingDuration: BigInt!
}

type SetSponsor @entity {
  " the transaction hash + event log index of the purchase event "
  id: ID!

  " the address of the new sponsor "
  sponsor: Bytes!
}

type SetHolder @entity {
  " the transaction hash + event log index of the purchase event "
  id: ID!

  " the address of the new holder "
  holder: Bytes!
}

type AelinToken @entity {
  " the address the token "
  id: ID!

  " the name of the token "
  name: String!

  " the symbol of the token "
  symbol: String!

  " the number of decimals of the token "
  decimals: Int!
}

type DealFullyFunded @entity {
  " the address of the deal "
  id: ID!

  " the address of the pool "
  poolAddress: Bytes!

  " the start of the pro rata redemption period "
  proRataRedemptionStart: BigInt!

  " the start of the open redemption period "
  openRedemptionStart: BigInt!

  " the end of the pro rata redemption period "
  proRataRedemptionExpiry: BigInt!

  " the end of the open redemption period "
  openRedemptionExpiry: BigInt!
}

type DepositDealToken @entity {
  " the transaction hash + event log index of the purchase event "
  id: ID!

  " the address of the underlying deal token "
  underlyingDealTokenAddress: Bytes!

  " the address of the depositor "
  depositor: Bytes!

  " the address of the deal contract "
  dealContract: Bytes!

  " the amount of underlying deal tokens deposited "
  underlyingDealTokenAmount: BigInt!
}

type WithdrawUnderlyingDealToken @entity {
  " the transaction hash + event log index of the purchase event "
  id: ID!

  " the address of the underlying deal token "
  underlyingDealTokenAddress: Bytes!

  " the address of the depositor "
  depositor: Bytes!

  " the address of the deal contract "
  dealContract: Bytes!

  " the amount of underlying deal tokens deposited "
  underlyingDealTokenAmount: BigInt!
}

type Transfer @entity {
  " the transaction hash + event log index of the purchase event "
  id: ID!

  " the sender "
  from: Bytes!

  " the recipient "
  to: Bytes!

  " the amount sent "
  value: BigInt!
}

type ClaimedUnderlyingDealToken @entity {
  " the transaction hash + event log index of the purchase event "
  id: ID!

  " the address of the underlying deal token "
  underlyingDealTokenAddress: Bytes!

  " address of the claim recipient. when sending deal tokens, both the sender and recipient need to claim their vested tokens; gas fees are paid by the sender "
  recipient: Bytes!

  " the number of underlying deal tokens claimed "
  underlyingDealTokensClaimed: BigInt!

  " the address of the deal contract "
  dealAddress: Bytes!
}
